________________________________________________________________________________

||||||||||||||||||||||||| CALCULATING TURNS FOR 1 PATH |||||||||||||||||||||||||

To calculate the moves one path takes:
ants + the rooms between source and sink OR
ants + the number of edges minus 1

	Example1:

			ANTS: 7
				source
				|
				room1
				|
				room2
				|
				room3
				|
				sink

				There are 3 rooms between the source and the sink, and 7 ants.
				3 + 7 = 10.
				Here it takes 10 moves.

				OR

				There are 4 edges(links) and 7 ants.
				Add them together and substract 1.
				4 + 7 - 1 = 10.
				10 moves again.

	Example2:

			ANTS: 12
				source
				|
				room1
				|
				room2
				|
				room3
				|
				room4
				|
				room5
				|
				sink

				There are 5 rooms between the source and the sink, and 12 ants.
				5 + 12 = 17.
				Here it takes 17 moves.

				OR

				There are 6 edges(links) and 12 ants.
				Add them together and substract 1.
				6 + 12 - 1 = 17.
				17 moves again.

________________________________________________________________________________


|||||||||||||||||||||||||||||| MAXIMUM PATHS = 2 |||||||||||||||||||||||||||||||

If the maximum paths is 2, wether to use 1 or 2 paths can be calculated.
The difference between the number of edges of the two paths is the magic number.
That number is the highest amount of ants when to use 1 path.

	Example1:

			Path1: 8 edges
			Path2: 13 edges
			Difference: 5.

						Number of turns it takes with:
				ANTS:	PATH1:	USING BOTH PATHS(1 ant in Path2):
				7		14			13
				6		13			13
				5		12			13

		With 7 ants it's better to use both paths as it takes 13 turns,
		where just using the shortest path takes 14 turns.

		With 6 ants it doesn't matter which on to choose - path1 or both.

		With 5 ants - which is the difference between the number of edges,
		It is better to use the shortest path only, as it takes less turns.


How it could look like in the code:

if (paths->max == 2)
{
	If (data->ants > (paths->path2->edge_nb) - (paths->path1->edge_nb))
		use_two_paths(data, paths);
	else
		use_shortest_path(data, paths);
}

Calculating how many ants go to the two paths:

void	use_two_paths(t_data *data, t_path paths)
{
	int		ants_in_path1;
	int		ants_in_path2;

	ants_in_path2 = (data->ants - Diff) / 2;
	ants_in_path1 = data->ants - ants_in_path2;
	print_the_solution;
}


________________________________________________________________________________


|||||||||||||||||||||||||||| WHEN TO ADD PATH3 |||||||||||||||||||||||||||||||||

The third path is added when the number of ants reaches the equation:
	Ants = Diff1 + 3 + (Diff2 x 2),
	Where Diff1 = (Path2->edges - Path1->edges), and
	Diff2 = (Path3->edges - Path2->edges).

Example1:

			Path1: 8 edges
			Path2: 13 edges
			Path3: 14 edges
			Difference1 = 5 (Path2 - Path1).
			Difference2 = 1 (Path3 - Path2).

						Number of turns it takes with:
				ANTS:	USING 2 PATHS:		USING 3 PATHS:
				7			13					14
				8			14					14
				9			14					14
				10			15					14

		With 10 ants it's better to use 3 paths instead of 2.
		Now let's check the calculation:
		Ants = Diff1 + 3 + (Diff2 x 2) =
		Ants =   5   + 3 + (  1   x 2) =
		Ants =      8    + (    2    ) =
		Ants = 10.



________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________



||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||| HOW MANY PATHS WE WILL USE ||||||||||||||||||||||||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

There is one pattern to rule them all.
This pattern gives us the number of ants when the new path must be added.


			Path1		Path2		Path3		Path4		Path5		Path6
edges:		8			10			11			11			15			18


			WITH 5 EDGES:
Path5->edges + 1 = Big_edge = 16.

(Big_edge - Path1->edges) + (Big_edge - Path2->edges) + (Big_edge - Path3->edges)
+ (Big_edge - Path4->edges) + 1 = When to add fifth path!
	=
(16 - 8) + (16 - 10) + (16 - 11) + (16 - 11) + 1  = When to add fifth path!
	=
8 + 6 + 5 + 5 + 1 = 25


			WITH 6 EDGES:

Path6->edges + 1 = Big_edge = 19.

(Big_edge - Path1->edges) + (Big_edge - Path2->edges) + (Big_edge - Path3->edges)
+ (Big_edge - Path4->edges) + (Big_edge - path5->edges) + 1 = When to add sixth path!
	=
(19 - 8) + (19 - 10) + (19 - 11) + (19 - 11) + (19 - 15) + 1 = When to add sixth path!
	=
11 + 9 + 8 + 8 + 4 + 1 = 41





________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________



|||||||||||||||||||||||||| FINDING BOTTLENECKS |||||||||||||||||||||||||||||||||
	Do we even need to find them??


When two terminal nodes are given, they are typically referred to as the source
and the sink. In a directed, weighted flow network,
the minimum cut separates the source and sink vertices
and minimizes the total weight on the edges
that are directed from the source side of the cut to the sink side of the cut.
As shown in the max-flow min-cut theorem,
the weight of this cut equals the maximum amount of flow
that can be sent from the source to the sink in the given network.

In a weighted, undirected network,
it is possible to calculate the cut
that separates a particular pair of vertices from each other
and has minimum possible weight.
A system of cuts that solves this problem for every possible vertex pair
can be collected into a structure known as the Gomoryâ€“Hu tree of the graph.

A generalization of the minimum cut problem with terminals is the k-terminal cut,
or multi-terminal cut.
This problem is NP-hard, even for {\displaystyle k=3}k=3.[3]
	https://en.wikipedia.org/wiki/Minimum_cut 

________________________________________________________________________________

|||||||||||||||||||||||||||||||||| V D S |||||||||||||||||||||||||||||||||||||||

Very important:
https://matthewdaws.github.io/blog/2015-06-08-Paths.html 
https://matthewdaws.github.io/blog/2015-06-15-Paths-Implementation.html 

Maybe could use this?:
https://iajit.org/portal/PDF/vol.12,no.6/7418.pdf 


